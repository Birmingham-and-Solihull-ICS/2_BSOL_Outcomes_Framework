---
title: "Outcome Framework Process Documentation"
date: "`r Sys.Date()`"
author: Siti Hassan
date-format: "D MMMM YYYY"
format:
  html:
    toc: true
    toc-depth: 2
    toc-expand: true
    toc-location: left
    toc-title: Table of Contents
    number-sections: false
    code-fold: true
    code-summary: "Show example"
    embed-resources: true
    standalone: true
    link-external-icon: true
    link-external-newwindow: true
    citations-hover: true
    footnotes-hover: true
    callout-appearance: simple
    callout-collapse: true
    cap-location: bottom
    title-block-banner: '#005EB8'
    backgroundcolor: '#f0f4f5'
    highlight-style: tango

execute:
  echo: true          
  cache: true
  warning: false
  error: false
  freeze: auto        
editor: visual
---

```{r}
#| label: setup-db
#| echo: false
library(DBI)
library(odbc)
sql_connection <- dbConnect(
  odbc(),
  Driver = "SQL Server",
  Server = "MLCSU-BI-SQL",
  Database = "EAT_Reporting_BSOL",
  Trusted_Connection = "True"
)

```

# Introduction

This documentation outlines the steps for building a dataset of indicators that draw from multiple sources, with the purpose of monitoring patient outcomes across several domains, including **Cancer, Frailty and End of Life, Cardiovascular Health, Mental Health, Respiratory Health, Mortality, Children and Young People, Prevention,** and **Other**.

Additionally, this dataset will support monitoring variations across **geographic levels** such as **PCN, ICN, Ward, Locality (resident),** and **Local Authority District,** as well as **demographic groups**. This will allow us to assess inequalities by ethnicity and deprivation. There are approximately 120 indicators across 7 domains, and each indicator has its own requirements for dataset construction. This documentation will guide you through the steps involved in building an indicator, based on the conditions specified in the metadata file, which can be found [here](https://birminghamandsolihullccg.sharepoint.com/:f:/r/sites/BirminghamandSolihullIntegratedIntelligenceHub/Shared%20Documents/Outcome%20Framework%20Rebuild/Metadata?csf=1&web=1&e=loJrNj).

To enable the calculation of **rates, percentages, ratios, life expectancy, and other outcome measures** across various geographic levels and demographic groups, the dataset includes the following key components:

-   **Indicator metadata**: IDs, start and end dates of the indicator reporting period.

-   **Numerator**: The count of events or the subset of the total population who experienced the outcome of interest.

-   **Denominator**: Total population against which the numerator is measured.

-   **Indicator value**: Calculated measures such as crude rates, directly age standardised rates (DASR), percentages, ratios, life expectancy, and other value types.

-   **Confidence intervals**: Lower and upper 95% confidence bounds for the indicator value.

-   **Demographic dimensions**: Breakdown by IMD quintile, age group, sex, and ethnicity.

-   **Geographic dimensions**: Breakdown by PCN, ICB for GP-level data, and Ward, Locality (resident), and Local Authority District (LAD) for resident population data.

-   **Additional metadata**: For example, `creation_date` (when the indicator was created), `source_code` (the source from which the indicator was derived), and `value_type_code` (the type of measure).

The dataset is structured using a **Fact--Dimension model**, where reference (dimension) tables are linked to the central fact table that stores the indicator values.

For an example of the underlying data structure, you can explore the following table:

``` sql
SELECT TOP 1000 * FROM [EAT_Reporting_BSOL].[OF].[OF2_Indicator_SQL_Data]
```

# Start Here

Begin by identifying the population type for the indicator in the [metadata](https://birminghamandsolihullccg.sharepoint.com/:f:/r/sites/BirminghamandSolihullIntegratedIntelligenceHub/Shared%20Documents/Outcome%20Framework%20Rebuild/Metadata?csf=1&web=1&e=loJrNj).

## A) Population type = Census

If the population type is **Census**, the population (denominator) for this indicator must be derived from Census population estimates to calculate rates or other value types.

Therefore, move to [**Chapter 2: Building Indicators Without Denominator**](#Chapter2)

*Examples:* indicators from the **SUS** and **Mortality** datasets. These indicators **do not have predefined denominators** and use Census estimates to derive the population.

## B) Population type = GP registered and a denominator column exists

If the population type is **GP registered**, identify whether the data source has a **denominator column**. For example, **QOF**, **CVD Prevent**, and **Fingertips** provide a denominator column in their datasets.

Therefore, proceed to [**Chapter 1: Building Indicators With Denominator**](#Chapter1)**.**

## C) Population type â‰  Census and no denominator column exists

If the population type is **not Census** and there is **no denominator column** in the data source, proceed to **Chapter 2** to derive the **numerator** and to **Chapter 3** to derive the **denominator**.

All of these datasets feed into the **Outcomes Framework (OF) dataset**.

## Flowchart

```{mermaid}
flowchart TB
A((Start))
B{"Population Type = Census?"}
C{"Denominator column in data?"}

L1(["Chapter 2: Building Indicators without Denominator"])
L2(["Non-predefined denominator data"])
L3(["OF dataset"])

M1(["Chapter 1: Building Indicators with Denominator"])
M2(["Predefined denominator data"])

R1(["Derive numerator using steps in Chapter 2"])
R2(["Derive denominator using steps in Chapter 3"])

A --> B
B -- "Yes" --> L1
B -- "No" --> C
C -- "Yes" --> M1
C -- "No" --> R1
R1 --> R2
L1 --> L2
M1 --> M2
R2 --> M2
L2 --> L3
M2 --> L3

classDef start fill:#A5D6A7,stroke:#2E7D32,stroke-width:1px,color:#000
classDef decision1 fill:#D1C4E9,stroke:#6A1B9A,stroke-width:1px,color:#000
classDef decision2 fill:#EF9A9A,stroke:#C62828,stroke-width:1px,color:#000
classDef step fill:#BBDEFB,stroke:#1E88E5,stroke-width:1px,color:#000
classDef orange fill:#FFD180,stroke:#F57C00,stroke-width:1px,color:#000
classDef green fill:#C8E6C9,stroke:#388E3C,stroke-width:1px,color:#000

class A start
class B decision1
class C decision2
class L1,M1,R1,R2 step
class L2 orange
class M2 green
class L3 orange
```

# Chapter 1: Building Indicators from Scratch (with Denominator) {#Chapter1}

The following steps guide you through building OF indicators with pre-defined denominators - i.e., when the data source already includes a denominator column. Examples include indicators from **QOF**, **CVD Prevent**, and **Fingertips**.

## 1.0 Create staging tables {#step1}

We begin by creating two staging tables to store data at different steps:

-   One table stores the processed indicator data, which will be used to update the final OF dataset;

-   The other stores data containing all required columns, enabling us to generate the processed indicator data for the final OF dataset.

### 1.1 Staging table for processed indicator data {#step1.1}

This table stores the processed indicator data for each required geography level and demographic split. The data will then be used to update the final indicator data table.

It must therefore include all columns defined in the specified data structure of the final table (i.e., `[EAT_Reporting_BSOL].[OF].[OF2_Indicator_SQL_Data]`).

```{sql}
#| connection: sql_connection
#| code-fold: true
#| code-summary: "Show example"
#| eval: false

DROP TABLE IF EXISTS #Staging_QOF_Data;

CREATE TABLE #Staging_QOF_Data (
  [indicator_id] INT,
  [start_date] DATE,
  [end_date] DATE,
  [numerator] FLOAT,
  [denominator] FLOAT,
  [indicator_value] FLOAT,
  [lower_ci95] FLOAT,
  [upper_ci95] FLOAT,
  [imd] VARCHAR(10),
  [geography] VARCHAR(100),
  [age_group] VARCHAR(100),
  [sex] VARCHAR(10),
  [ethnicity] VARCHAR(100),
  [creation_date] DATE,
  [value_type] VARCHAR(100),
  [source] VARCHAR(10)
);

```

### 1.2 Temporary table for GP-level raw data {#step1.2}

Indicators with a pre-defined denominator are at the GP level. Therefore, we need a temporary table to store data at this level, which can then be used to aggregate data to higher levels (i.e., PCNs and ICB).

Create this temporary table to store the lowest-level data---at the GP level---which will subsequently be used to aggregate data to higher levels such as PCN and ICB.

It must include the columns required to build the indicator data at the chosen geography level and by demographic split, so that the results can be stored in the staging table created in [Step 1.1](#step1.1).

This table also requires additional columns, such as GP practice codes and their corresponding PCN codes, to enable grouping at higher levels.

These are the columns required for the GP-level data:

-   `indicator_id`

-   `start_date` and `end_date`

-   `numerator`

-   `denominator`

-   `indicator_value`

-   `lower_ci9` and `upper_ci95`

-   `imd`, `age_group`, `sex`, and `ethnicity`

-   `creation_date`

-   `value_type`

-   `source`

-   `GP`

-   `PCN`

## 2.0 Build GP-level data {#Step2}

From this point onwards, the steps will outline how to build GP-level data in the table created in [Step 1.2](#step1.2), which will be used to aggregate data to higher levels (i.e., **PCN** and **ICB**).

If the data source does not contain GP-level data but instead provides higher-level data such as PCN or ICB, you can continue building the dataset at the available level (e.g., PCN). The required columns remain the same; the only difference is that the lowest geography level will be PCN, and the data will then be aggregated to the ICB level.

Similarly, if the data source only provides ICB-level data, you can continue building the dataset as normal with all the required columns, without the need for aggregation since ICB is already the highest level.

### 2.1 Identify the indicator's year type {#Step2.1}

Identify the year type of the indicator in the [metadata](https://birminghamandsolihullccg.sharepoint.com/:f:/r/sites/BirminghamandSolihullIntegratedIntelligenceHub/Shared%20Documents/Outcome%20Framework%20Rebuild/Metadata?csf=1&web=1&e=2HFEtp) file.

If the year type is either **Financial year** or **Calendar year**, use the following reference table and go to [Step 2.1.1](#step2.1.1) to update the `start_date` and `end_date` of the indicator data.

```{sql}
#| connection: sql_connection
#| code-fold: true
#| code-summary: "Show code"
#| eval: false

SELECT TOP 1000 * FROM [Reference].[dbo].[DIM_tbDate]
```

Otherwise, update the `start_date`and `end_date` based on how the time period in the data source is structured.

#### 2.1.1 Get Start and End Dates {#Step2.1.1}

The temporary GP-level data must have the `start_date` and `end_date` columns, which correspond to the start and end of the reporting period for that indicator.

You can use the Date reference table above to obtain the start and end dates by joining on the matching data column.

```{sql}
#| connection: sql_connection
#| code-fold: true
#| code-summary: "Show example"
#| eval: false

SELECT   T2.[HCSStartOfYearDate]  AS start_date
        ,T2.[HCSEndOfYearDate]    AS end_date
INTO    #GP_data
FROM    [AnalystGlobal].[Performance].[QOFIndicatorsAndPrevalence] AS T1
INNER JOIN    [Reference].[dbo].[DIM_tbDate] AS T2
ON      T1.FinancialYear = T2.HCSFinancialYearName
GROUP BY  T2.[HCSStartOfYearDate]  
		      ,T2.[HCSEndOfYearDate]  
```

**Note**: Be mindful of duplicate dates that may result from joining the two tables. Ensure that the start and end dates are unique for each year type. For example, *2024-04-01* and *2025-03-31* are the start and end dates, respectively, for the 2024/25 financial year.

### 2.2 Assign indicator ID {#Step2.2}

Identify the indicator ID from the [metadata](https://birminghamandsolihullccg.sharepoint.com/:f:/r/sites/BirminghamandSolihullIntegratedIntelligenceHub/Shared%20Documents/Outcome%20Framework%20Rebuild/Metadata?csf=1&web=1&e=2HFEtp) file, and assign the ID to the respective column `indicator_id` in the temporary GP-level data.

```{sql}
#| connection: sql_connection
#| code-fold: true
#| code-summary: "Show example"
#| eval: false

SELECT 1 AS indicator_id
INTO #GP_data
```

### 2.3 Extract numerator {#Step2.3}

Extract counts based on the numerator definition for that indicator in the [metadata](https://birminghamandsolihullccg.sharepoint.com/:f:/r/sites/BirminghamandSolihullIntegratedIntelligenceHub/Shared%20Documents/Outcome%20Framework%20Rebuild/Metadata?csf=1&web=1&e=2HFEtp) file at the GP level, including IMD **and/or** Ethnicity splits if available. This will form the `numerator` column in the temporary GP data.

```{sql}
#| connection: sql_connection
#| code-fold: true
#| code-summary: "Show example"
#| eval: false

SELECT T1.[DiseaseRegisterSize] AS numerator
INTO #GP_data
FROM [AnalystGlobal].[Performance].[QOFIndicatorsAndPrevalence] AS T1
INNER JOIN EAT_Reporting_BSOL.Reference.BSOL_ICS_PracticeMapped AS T2
ON T1.PracticeCode = T2.GPPracticeCode_Original
WHERE T2.ICS_2223 = 'BSOL'
AND IndicatorCode = 'STIA001'
AND DiseaseRegisterSize IS NOT NULL
AND  PracticeCode  <> 'M88006'
```

### 2.4 Extract denominator {#Step2.4}

Similarly, extract counts from the denominator column in the data source. This will form the `denominator` column in the temporary GP data.

```{sql}
#| connection: sql_connection
#| code-fold: true
#| code-summary: "Show example"
#| eval: false


SELECT T1.[PracticeListsize] AS denominator
INTO #GP_data
FROM [AnalystGlobal].[Performance].[QOFIndicatorsAndPrevalence] AS T1
INNER JOIN EAT_Reporting_BSOL.Reference.BSOL_ICS_PracticeMapped AS T2
ON T1.PracticeCode = T2.GPPracticeCode_Original
WHERE T2.ICS_2223 = 'BSOL'
AND IndicatorCode = 'STIA001'
AND DiseaseRegisterSize IS NOT NULL
AND  PracticeCode  <> 'M88006'
```

### 2.5 Update indicator value & CI95 bounds {#Step2.5}

Leave the`indicator_value`, `lower_ci95` and `upper_ci95` (confidence interval (CI) bounds) columns as NULL as they will be calculated in a later step that is separate from this process.

```{sql}
#| connection: sql_connection
#| code-fold: true
#| code-summary: "Show example"
#| eval: false


SELECT     NULL AS [indicator_value] 
          ,NULL As [lower_ci95]
          ,NULL As [upper_ci95]
INTO #GP_data
```

### 2.6 Update columns {#Step2.6}

#### 2.6.1 IMD {#Step2.6.1}

If the data source contains IMD splits, extract the values from the `IMD` column in the data source and reference them in the temporary GP-level data.

Once you have extracted the IMD column from the data source and inserted it into the GP-level data, you will need map each IMD quintile to its corresponding `imd_code`, which is a unique code from the OF reference table below:

```{sql}
#| connection: sql_connection
#| code-fold: true
#| code-summary: "Show code"
#| eval: false
SELECT TOP (1000) [imd_code]
      ,[imd_quintile]
      ,[imd_quintile_desc]
  FROM [EAT_Reporting_BSOL].[OF].[OF2_Reference_IMD]
```

Please note that if no IMD splits are available in the data source, assign the code **'999'** to the IMD column in the temporary GP-level data, which maps to **'All (Persons)'** category.

```{sql}
#| connection: sql_connection
#| code-fold: true
#| code-summary: "Show example"
#| eval: false


SELECT     999 AS imd 
INTO #GP_data
```

Additionally, if the data source contains IMD splits but some rows have missing quintiles, replace the NULL values in the data source with **'Unknown'** category. These can then be mapped to code **'-99'** using the reference table above.

#### 2.6.2 Ethnicity {#Step2.6.2}

If the data source contains ethnicity splits, extract the values from the `ethnicity` column in the data source and reference them in the temporary GP-level data.

Once you have extracted the Ethnicity column from the data source and inserted it into the GP-level data, you will need map each ethnicity to its corresponding `ethnicity_code`, which is a unique code from the OF reference table below:

```{sql}
#| connection: sql_connection
#| code-fold: true
#| code-summary: "Show code"
#| eval: false
SELECT TOP (1000) [ethnicity_code]
      ,[nhs_code]
      ,[nhs_code_definitions]
      ,[census_ethnic_group]
      ,[definitions]
      ,[main5_code]
      ,[main5]
      ,[OF_code]
      ,[OF_grouping11]
      ,[cvd_prevent_grouping]
  FROM [EAT_Reporting_BSOL].[OF].[OF2_Reference_Ethnicity]
```

Please note that if no ethnicity splits are available in the data source, assign the code **'999'** to the ethnicity column in the temporary GP-level data, which maps to **'All (Persons)'** category.

Additionally, if the data source contains ethnicity splits but some rows have missing or unknown ethnicity, replace the values with **'Unknown'**.These can then be mapped to code **'-99'** using the reference table above.

#### 2.6.3 Sex {#Step2.6.3}

Assign the code **'999'** to the `sex` column in the temporary GP-level data, which corresponds to **'All (Persons)'** category as specified in the reference table below:

```{sql}
#| connection: sql_connection
#| code-fold: true
#| code-summary: "Show code"
#| eval: false
SELECT TOP (1000) [sex_code]
      ,[sex]
  FROM [EAT_Reporting_BSOL].[OF].[OF2_Reference_Sex]
```

#### 2.6.4 Age group {#Step2.6.4}

Assign the code **'999'** to the `age_group` column in the temporary GP-level data, which corresponds to **'All (Persons)'** category as specified in the reference table below:

```{sql}
#| connection: sql_connection
#| code-fold: true
#| code-summary: "Show code"
#| eval: false
SELECT TOP (1000) [age_code]
      ,[age_type]
      ,[min_age]
      ,[max_age]
      ,[age_group]
      ,[age_group_label]
      ,[age_unit]
  FROM [EAT_Reporting_BSOL].[OF].[OF2_Reference_Age_Group]
```

#### 2.6.5 Creation date {#Step2.6.5}

Update the indicator `creation_date` column with the current date.

```{sql}
#| connection: sql_connection
#| code-fold: true
#| code-summary: "Show example"
#| eval: false

SELECT getdate() AS CreationDate
INTO #GP_data
```

#### 2.6.6 Value type {#Step2.6.6}

The value type defines the type of calculation required for a particular indicator. It may include (in)directly age standardised rate, crude rate, percentage, ratio, life expectancy, count, or other.

Identify the value type of the indicator from the [metadata](https://birminghamandsolihullccg.sharepoint.com/:f:/r/sites/BirminghamandSolihullIntegratedIntelligenceHub/Shared%20Documents/Outcome%20Framework%20Rebuild/Metadata?csf=1&web=1&e=2HFEtp) file, and assign the corresponding code to the `value_type` column in the temporary GP-level data table using the reference table below:

```{sql}
#| connection: sql_connection
#| code-fold: true
#| code-summary: "Show code"
#| eval: false

SELECT TOP (1000) [value_type_code]
      ,[value_type]
  FROM [EAT_Reporting_BSOL].[OF].[OF2_Reference_Value_Type]
```

#### 2.6.7 Source {#Step2.6.7}

The `source` column defines where the indicator data is extracted from. Possible sources include data warehouse (SQL), SharePoint site, API, or other.

Assign code '1' to the `source` column in the temporary GP-level data table if the indicator data is extracted from our data warehouse.

Use the following reference table for further details:

```{sql}
#| connection: sql_connection
#| code-fold: true
#| code-summary: "Show code"
#| eval: false
SELECT TOP (1000) [source_code]
                  ,[source]
  FROM [EAT_Reporting_BSOL].[OF].[OF2_Reference_Source]
```

### 2.7 Add GP and PCN columns {#Step2.7}

To enable aggregation of data into higher levels, such as PCN and ICB, additional columns such as GP and PCN need to be added to the existing temporary GP-level data table.

Use the following reference table to get the GP and corresponding PCN codes:

```{sql}
#| connection: sql_connection
#| code-fold: true
#| code-summary: "Show code"
#| eval: false
EAT_Reporting_BSOL.Reference.BSOL_ICS_PracticeMapped
```

Make sure to filter data by **BSOL practices only**, **remove 'Cape Hill Practice' and Closed practices**.

```{sql}
#| connection: sql_connection
#| code-fold: true
#| code-summary: "Show example"
#| eval: false

SELECT      DISTINCT T2.[GPPracticeCode_Original] AS GP
                ,T2.[PCN code] AS PCN
FROM        [AnalystGlobal].[Performance].[QOFIndicatorsAndPrevalence] T1
INNER JOIN  EAT_Reporting_BSOL.Reference.BSOL_ICS_PracticeMapped T2
ON          T1.[PracticeCode] = T2.[GPPracticeCode_Original]
WHERE       T2.ICS_2223 = 'BSOL'
AND             IndicatorCode = 'STIA001'
AND             DiseaseRegisterSize IS NOT NULL
AND             PracticeCode  <> 'M88006' --Delete cape hill practice
AND         PCN <> 'Closed practice'
```

### 2.8 Putting GP-level data together {#Step2.8}

Here's an example of building indicator data at the GP level using the QOF dataset.

```{sql}
#| connection: sql_connection
#| code-fold: true
#| code-summary: "Show code"
#| eval: false
/*========================================================================
 Indicator ID 1 - Reference ID 212 - Stroke: QOF prevalence (all ages)          
==========================================================================*/

DROP TABLE IF EXISTS #GP_Data;

SELECT DISTINCT
     1                           AS [indicator_id]       
    ,T3.[HCSStartOfYearDate]      AS [start_date]
    ,T3.[HCSEndOfYearDate]        AS [end_date]
    ,T1.[DiseaseRegisterSize]     AS [disease_register_size] -- numerator
    ,T1.[PracticeListsize]        AS [practice_list_size]    -- denominator
    ,CAST(NULL AS FLOAT)          AS [indicator_value]
    ,CAST(NULL AS FLOAT)          AS [lower_ci95]
    ,CAST(NULL AS FLOAT)          AS [upper_ci95]
    999                         AS [imd]            -- All IMD
    ,T2.[GPPracticeCode_Original] AS [gp]             -- GP
    ,T2.[PCN code]                AS [pcn]            -- PCN
    ,999                        AS [age_group]       -- All Ages
    ,,999                       AS [sex]            -- All Persons
    ,999                        AS [ethnicity]      -- All ethnicit
    ,GETDATE()                    AS [creation_date]
    ,2                          AS [value_type]      -- Percentage
    ,1                          AS [source]         -- SQL
INTO #GP_Data
FROM [AnalystGlobal].[Performance].[QOFIndicatorsAndPrevalence] AS T1
INNER JOIN EAT_Reporting_BSOL.[Reference].[BSOL_ICS_PracticeMapped] AS T2
    ON T1.[PracticeCode] = T2.[GPPracticeCode_Original]
INNER JOIN [Reference].[dbo].[DIM_tbDate] AS T3
    ON T1.[FinancialYear] = T3.[HCSFinancialYearName]
WHERE
    T2.[ICS_2223] = 'BSOL'
    AND T1.[IndicatorCode] = 'STIA001'
    AND T1.[DiseaseRegisterSize] IS NOT NULL
    AND T1.[PracticeCode] <> 'M88006';  -- Delete Cape Hill practice
```

## 3.0 Build PCN-level data {#Step3}

Use the temporary GP-level data and aggregate it to the PCN-level data by grouping on the required columns.

Then, insert the aggregated data into the staging processed indicator data table created in [Step 1.1](Step1.1).

```{sql}
#| connection: sql_connection
#| code-fold: true
#| code-summary: "Show example"
#| eval: false


--PCN level data
INSERT INTO #Staging_QOF_Data (
        [indicator_id]
       ,[start_date]
       ,[end_date]
       ,[numerator]
       ,[denominator]
       ,[indicator_value]
       ,[lower_ci95]
       ,[upper_ci95] 
       ,[imd] 
       ,[geography] 
       ,[age_group] 
       ,[sex] 
       ,[ethnicity] 
       ,[creation_date] 
       ,[value_type] 
       ,[source] 
       )
       (
  SELECT  
         [indicator_id]
        ,[start_date]
        ,[end_date]
        ,sum(disease_register_size)
        ,sum(practice_list_size)
        ,[indicator_value] 
        ,[lower_ci95]
        ,[upper_ci95] 
        ,[imd]           --All IMD
        ,[pcn]           -- Geography
        ,[age_group]     --All Ages
        ,[sex]           -- All Persons sex
        ,[ethnicity]     --All ethnicity
        ,[creation_ate]
        ,[value_type]    --Percentage
        ,[source]        --SQL
 FROM  #GP_Data
 GROUP BY    
         [indicator_id]
        ,[start_date]
        ,[end_date]
        ,[indicator_value] 
        ,[lower_ci95]
        ,[upper_ci95] 
        ,[imd]          
        ,[pcn]          
        ,[age_group]     
        ,[sex]          
        ,[ethnicity]    
        ,[creation_ate]
        ,[value_type]   
        ,[source]       
 )
```

Note that the `geography` column now contains PCN codes.

## 4.0 Build ICB-level data {#Step4}

Use the temporary GP-level data and aggregate it to the ICB-level data by grouping on the required columns.

Then, insert the aggregated data into the staging processed indicator data table created in [Step 1.1](Step1.1).

```{sql}
#| connection: sql_connection
#| code-fold: true
#| code-summary: "Show example"
#| eval: false

--ICB level data

INSERT INTO #Staging_QOF_Data (
        [indicator_id]
       ,[start_date]
       ,[end_date]
       ,[numerator]
       ,[denominator]
       ,[indicator_value]
       ,[lower_ci95]
       ,[upper_ci95] 
       ,[imd] 
       ,[geography] 
       ,[age_group] 
       ,[sex] 
       ,[ethnicity] 
       ,[creation_date] 
       ,[value_type] 
       ,[source]
       )
       (
  SELECT [indicator_id]
        ,[start_date]
        ,[end_date]
        ,sum(disease_register_size)
        ,sum(practice_list_size)
        ,[indicator_value] 
        ,[lower_ci95]
        ,[upper_ci95] 
        ,[imd]           --All IMD
        ,'E38000258'     --BSOL ICB code
        ,[age_group]     --All Ages
        ,[sex]           -- All Persons sex
        ,[ethnicity]     --All ethnicity
        ,[creation_ate]
        ,[value_type]    --Percentage
        ,[source]        --SQL
 FROM  #GP_Data
 GROUP BY 
         [indicator_id]
        ,[start_date]
        ,[end_date]
        ,[indicator_value] 
        ,[lower_ci95]
        ,[upper_ci95] 
        ,[imd]           
        ,[age_group]     
        ,[sex]           
        ,[ethnicity]     
        ,[creation_ate]
        ,[value_type]    
        ,[source]        
 )
```

Note that the `geography` column now contains the BSOL ICB code (E38000258).

## 5.0 Update geography {#Step5}

Update the `geography` column in the staging processed indicator data table to ensure that it uses the `aggregation_id` from the following reference table:

```{sql}
#| connection: sql_connection
#| code-fold: true
#| code-summary: "Show code"
#| eval: false
SELECT TOP (1000) [aggregation_id]
      ,[aggregation_type]
      ,[aggregation_code]
      ,[aggregation_label]
FROM [EAT_Reporting_BSOL].[OF].[OF2_Reference_Geography]
```

When updating the `geography` column, the **`aggregation_id`** can be obtained by joining data based on the aggregation type (PCN or ICB) and the aggregation code (PCN or ICB code).

## 6.0 Update final table

Delete the old indicator data from the final table `[EAT_Reporting_BSOL].[OF].[OF2_IndicatorSQLData]` before re-inserting new data to ensure that only the latest data is in the table.

```{sql}
#| connection: sql_connection
#| code-fold: true
#| code-summary: "Show example"
#| eval: false

DELETE FROM [EAT_Reporting_BSOL].[OF].[OF2_IndicatorSQLData]
WHERE indicator_id = 1

INSERT INTO [EAT_Reporting_BSOL].[OF].[OF2_IndicatorSQLData] (
         [indicator_id]
       , [start_date]
       , [end_date]
       , [numerator]
       , [denominator]
       , [indicator_value]
       , [lower_ci95]
       , [upper_ci95] 
       , [imd_code] 
       , [aggregation_id] 
       , [age_group_code] 
       , [sex_code] 
       , [ethnicity_code] 
       , [creation_date] 
       , [value_type_code] 
       , [source_code] 
       )
       (
SELECT  *
FROM #Staging_QOF_Data
  
        )
```

# Chapter 2: Building Indicators from Scratch (without Denominator) {#Chapter2}

The following steps guide you through building OF indicators without pre-defined denominators - i.e., when the data source does not include a denominator column. Examples include indicators from **SUS** and **Mortality**.

In this case, the denominator will be derived using population estimates from the Census, while the numerator will come from the data source. Since the data source is patient-level, the numerator will be calculated by grouping patient-level activity.

In addition, the geography levels for these indicators are based on **residence**---i.e., Ward, Locality (resident), and Local Authority District (LAD)---rather than GP registration, where the levels would instead be PCN and ICB.

## 1.0 Create staging tables {#sec-2.1-create-staging-tables}

We begin by creating three staging tables to store data at different steps:

-   One table stores all BSOL residents based on admission episodes;

-   One table stores the numerator dataset;

-   The other stores the processed indicator data, which will be used to update the final OF dataset.

### 1.1 Temporary table for BSOL residents {#sec-1-temporary-table-for-bsol-residents}

This temporary table will store all admission episodes for BSOL residents, which will subsequently be used to create the numerator dataset.

The purpose of this table is to narrow down the admission episodes to the relevant population.

```{sql}
#| connection: sql_connection
#| code-fold: true
#| code-summary: "Show example"
#| eval: false
DROP TABLE IF EXISTS #BSOL_OF_tbIndicator_PtsCohort_IP

CREATE TABLE    #BSOL_OF_tbIndicator_PtsCohort_IP (episode_id BIGINT NOT NULL)
```

### 1.2 Temporary table for numerator data {#sec-1.2-temporary-table-for-numerator-data}

This temporary table will store the numerator dataset, containing all columns required to create aggregated data at geographical levels (Ward, Locality Resident, LAD) and with demographic splits.

```{sql}
#| connection: sql_connection
#| code-fold: true
#| code-summary: "Show example"
#| eval: false

DROP TABLE IF EXISTS #BSOL_OF_tbStaging_NumeratorData

CREATE TABLE            #BSOL_OF_tbStaging_NumeratorData 

(                       [indicator_id]          INT
,                       [time_period]           INT
,                       [financial_year]        VARCHAR (7)
,                       [ethnicity_code]        VARCHAR (5)
,                       [sex]                   VARCHAR (25)
,                       [age]                   VARCHAR (25)
,                       [imd]                   VARCHAR (25)
,                       [lsoa_2011]             VARCHAR (9) 
,                       [lsoa_2021]             VARCHAR (9)
,                       [ward_code]             VARCHAR (9)
,                       [locality_res]          VARCHAR (10)
,                       [lad_code]              VARCHAR (9)
,                       [episode_id]            BIGINT NOT NULL 
,                       [numerator]             FLOAT
)

```

### 1.3 Staging table for processed indicator data {#sec-2.1.3-staging-table-for-processed-indicator-data}

This table will store the processed indicator data for each required geography level and demographic split, which will subsequently be used to update the final indicator data table.

It must therefore include all columns defined in the specified data structure of the final table (i.e., `[EAT_Reporting_BSOL].[OF].[OF2_Indicator_SQL_Data]`).

```{sql}
#| connection: sql_connection
#| code-fold: true
#| code-summary: "Show example"
#| eval: false

DROP TABLE IF EXISTS #BSOL_OF_tbStaging_SUS_Data

CREATE TABLE            #BSOL_OF_tbStaging_SUS_Data 

(                       
                        [indicator_id] INT
,                       [start_date] DATE
,                       [end_date] DATE
,                       [numerator] FLOAT
,                       [denominator] FLOAT
,                       [indicator_value] FLOAT
,                       [lower_ci95] FLOAT
,                       [upper_ci95] FLOAT
,                       [imd_code] VARCHAR (10)
,                       [aggregation_id] VARCHAR(12)
,                       [age_group_code] VARCHAR(10)
,                       [sex_code] VARCHAR(10)
,                       [ethnicity_code] VARCHAR(10)
,                       [creation_date] DATE
,                       [value_type_code] VARCHAR(10)
,                       [source_code] VARCHAR(10)
)

```

## 2.0 Get patient cohort {#sec-2.0-get-patient-cohort}

Create a cohort of BSOL residents by gathering all admission episodes within the specified period, filtered by patient geography within the BSOL footprint to narrow down the number of episodes.

Insert the episodes IDs into the temporary table for BSOL residents created in [Step 1.1](#sec-1-temporary-table-for-bsol-residents).

```{sql}
#| connection: sql_connection
#| code-fold: true
#| code-summary: "Show example"
#| eval: false

INSERT          INTO #BSOL_OF_tbIndicator_PtsCohort_IP   (episode_id)
(
SELECT          T1.EpisodeID
FROM            [EAT_Reporting].[dbo].[tbInpatientEpisodes] T1
INNER JOIN      [EAT_Reporting].[dbo].[tbIPPatientGeography] T2      
ON              T1.EpisodeId = T2.EpisodeId

WHERE           ReconciliationPoint BETWEEN  @start_month AND @end_month
AND             T2.OSLAUA  IN ('E08000025', 'E08000029')                    --Bham & Solihull LA

```

## 3.0 Extract numerator {#sec-3-extract-numerator}

Check the [metadata](https://birminghamandsolihullccg.sharepoint.com/:f:/r/sites/BirminghamandSolihullIntegratedIntelligenceHub/Shared%20Documents/Outcome%20Framework%20Rebuild/Metadata?csf=1&web=1&e=2HFEtp) file to get the definition of the numerator and extract it accordingly.

Apply all necessary filters specified in the metadata. For example: **diagnosis codes, admission methods, age at admission, diagnosis order,** and **order in spell.**

Group the data appropriately (for example, by episode ID) to calculate the numerator.

Insert the numerator, along with the indicator ID and episode ID, into the numerator dataset (`#BSOL_OF_tbStaging_NumeratorData`).

```{sql}
#| connection: sql_connection
#| code-fold: true
#| code-summary: "Show example"
#| eval: false

INSERT INTO     #BSOL_OF_tbStaging_NumeratorData
(               indicator_id
,               episode_id
,               numerator
)

(
SELECT          10                              AS [indicator_id]
,               T1.episode_id
,               SUM(1)                          AS [numerator]

FROM            #BSOL_OF_tbIndicator_PtsCohort_IP T1

INNER JOIN      EAT_Reporting.dbo.tbIpDiagnosisRelational T2
ON              T1.episode_id = T2.EpisodeID    

INNER JOIN      EAT_Reporting.dbo.tbInpatientEpisodes T3
ON              T1.episode_id = T3.EpisodeId

WHERE           1=1
AND             LEFT(T3.AdmissionMethodCode,1) = 2      --Emergency admissions
AND             T3.OrderInSpell =1                                      --First Episode in Spell
AND             LEFT(T2.DiagnosisCode,3) IN ('X60','X61','X62','X63','X64','X66','X67','X68','X69','X70','X71','X72','X73','X74','X75','X76','X77','X78','X79','X80','X81','X82','X83','X84')                                  --Self Harm

GROUP BY        T1.episode_id
)

```

## 4.0 Update columns {#sec-4-update-columns}

The following steps will guide you though updating the remaining columns in the numerator dataset (`#BSOL_OF_tbStaging_NumeratorData`).

### 4.1 Time period {#sec-4.1-time-period}

Use the time period column in the data source to update the corresponding column in the numerator dataset (`#BSOL_OF_tbStaging_NumeratorData`).

```{sql}
#| connection: sql_connection
#| code-fold: true
#| code-summary: "Show example"
#| eval: false

UPDATE      T1
SET         T1.[time_period]    = T2.[ReconciliationPoint]

FROM        #BSOL_OF_tbStaging_NumeratorData T1

INNER JOIN  [EAT_Reporting].[dbo].[tbInpatientEpisodes] T2
ON          T1.[episode_id] = T2.[EpisodeId] 

```

### 4.2 Financial year {#sec-2.4.2-financial-year}

Use the reference table below to map each time period to its corresponding financial year and update this column accordingly.

```{sql}
#| connection: sql_connection
#| code-fold: true
#| code-summary: "Show code"
#| eval: false

SELECT TOP 1000 * FROM [Reference].[dbo].[DIM_tbDate] 
```

```{sql}
#| connection: sql_connection
#| code-fold: true
#| code-summary: "Show example"
#| eval: false

UPDATE      T1

SET         T1.[financial_year] = T2.[HCSFinancialYearName]

FROM        #BSOL_OF_tbStaging_NumeratorData T1

INNER JOIN  [Reference].[dbo].[DIM_tbDate] T2

ON          T1.[time_period] = T2.[HCCSReconciliationPoint]

```

***Note:** Be mindful of duplicate dates that may result from using this reference table.*

### 4.3 Age {#sec-4.3-age}

Use the age column in the data source update the corresponding column in the numerator dataset (`#BSOL_OF_tbStaging_NumeratorData`).

```{sql}
#| connection: sql_connection
#| code-fold: true
#| code-summary: "Show example"
#| eval: false
UPDATE          T1
SET             T1.[age]            = T2.[AgeonAdmission]

FROM        #BSOL_OF_tbStaging_NumeratorData T1

INNER JOIN  [EAT_Reporting].[dbo].[tbInpatientEpisodes] T2
ON          T1.[episode_id] = T2.[EpisodeId]
```

### 4.4 Sex {#sec-2.4.4-sex}

Use the sex column in the data source to update the corresponding column in the numerator dataset (`#BSOL_OF_tbStaging_NumeratorData`).

Please use the reference table below to obtain the sex description.

```{sql}
#| connection: sql_connection
#| code-fold: true
#| code-summary: "Show code"
#| eval: false

SELECT TOP 1000 * FROM [Reference].[dbo].[DIM_tbGender]
```

```{sql}
#| connection: sql_connection
#| code-fold: true
#| code-summary: "Show example"
#| eval: false

UPDATE      T1
SET         T1.[sex]            = T3.[GenderDescription]

FROM        #BSOL_OF_tbStaging_NumeratorData T1

INNER JOIN  [EAT_Reporting].[dbo].[tbInpatientEpisodes] T2
ON          T1.[episode_id] = T2.[EpisodeId]

LEFT JOIN   [Reference].[dbo].[DIM_tbGender] T3
ON          T2.GenderCode = T3.GenderCode

```

### 4.5 Ethnicity {#sec-2.4.5-ethnicity}

First, use the following **local ethnicity demographic table** to update the ethnicity column in the numerator dataset (`#BSOL_OF_tbStaging_NumeratorData`).

```{sql}
#| connection: sql_connection
#| code-fold: true
#| code-summary: "Show code"
#| eval: false

SELECT TOP 1000 * FROM EAT_Reporting_BSOL.Demographic.Ethnicity
```

```{sql}
#| connection: sql_connection
#| code-fold: true
#| code-summary: "Show example"
#| eval: false
UPDATE      T1
SET         T1.[ethnicity_code] = T3.[Ethnic_Code]

FROM        #BSOL_OF_tbStaging_NumeratorData T1

INNER JOIN  [EAT_Reporting].[dbo].[tbInpatientEpisodes] T2
ON          T1.[episode_id] = T2.[EpisodeId]

INNER JOIN  EAT_Reporting_BSOL.Demographic.Ethnicity T3
ON          T2.[NHSNumber] = T3.[Pseudo_NHS_Number]

```

For any missing values, use the ethnicity column from **data source** to update these.

```{sql}
#| connection: sql_connection
#| code-fold: true
#| code-summary: "Show example"
#| eval: false
UPDATE      T1
SET         T1.[ethnicity_code] = T2.[EthnicCategoryCode] 

FROM        #BSOL_OF_tbStaging_NumeratorData T1

INNER JOIN  [EAT_Reporting].[dbo].[tbInpatientEpisodes] T2
ON          T1.[episode_id] = T2.[EpisodeId]

WHERE       T1.Ethnicity_Code IS NULL
```

Finally, **clean the ethnicity code** to ensure that the relevant codes are used consistently and correctly.

```{sql}
#| connection: sql_connection
#| code-fold: true
#| code-summary: "Show example"
#| eval: false

UPDATE       T1
SET          T1.[ethnicity_code] = 
    CASE 
        WHEN T1.[ethnicity_code] = '9' THEN '99' --Unknown
        WHEN T1.[ethnicity_code] = 'A*' THEN 'A' -- British
        WHEN T1.[ethnicity_code] = 'ZZ' THEN 'Z' -- Not stated
        WHEN T1.[ethnicity_code] IS NULL THEN '99' -- Unknown
        ELSE T1.[ethnicity_code] -- Keep the existing value if no condition matches
    END
from        #BSOL_OF_tbStaging_NumeratorData t1
```

### 4.6 LSOA 11 & LSOA 21 {#sec-2.4.6-lsoa-11--lsoa-21}

Use the LSOA columns in the data source to update the corresponding columns in the numerator dataset (`#BSOL_OF_tbStaging_NumeratorData`).

```{sql}
#| connection: sql_connection
#| code-fold: true
#| code-summary: "Show example"
#| eval: false


UPDATE      T1
SET         T1.[lsoa_2011]  = T2.[LowerlayerSuperOutputArea2011]
,           T1.[lsoa_2021]  = T2.[LowerlayerSuperOutputArea2021]
FROM        #BSOL_OF_tbStaging_NumeratorData T1

INNER JOIN  [EAT_Reporting].[dbo].[tbIPPatientGeography] T2 

ON          T1.[episode_id] = T2.[EpisodeId] 
```

If the LSOA 21 column is not available in the data source, use the reference table below to map LSOA 11 to LSOA 21.

```{sql}
#| connection: sql_connection
#| code-fold: true
#| code-summary: "Show code"
#| eval: false
SELECT TOP 1000 * FROM [EAT_Reporting_BSOL].[Reference].[LSOA_2011_to_LSOA_2021]
```

### 4.7 Ward {#sec-2.4.7-ward}

Use the reference table below to map LSOA 21 to Ward, and update the Ward column in the numerator dataset (`#BSOL_OF_tbStaging_NumeratorData`) accordingly.

```{sql}
#| connection: sql_connection
#| code-fold: true
#| code-summary: "Show code"
#| eval: false

SELECT TOP 1000 * FROM [EAT_Reporting_BSOL].[Reference].[LSOA_2021_WARD_LAD]
```

```{sql}
#| connection: sql_connection
#| code-fold: true
#| code-summary: "Show example"
#| eval: false

UPDATE      T1
SET         T1.[ward_code]  = T2.[WD22CD]
 
FROM        #BSOL_OF_tbStaging_NumeratorData T1
 
INNER JOIN  [EAT_Reporting_BSOL].[Reference].[LSOA_2021_WARD_LAD] T2
ON          T1.[lsoa_2021] = T2.[LSOA21CD]


```

### 4.8 LAD {#sec-2.4.8-lad}

Similarly, use the reference table below to map LSOA 21 to LAD, and update the LAD column in the numerator dataset (`#BSOL_OF_tbStaging_NumeratorData`) accordingly.

```{sql}
#| connection: sql_connection
#| code-fold: true
#| code-summary: "Show code"
#| eval: false

SELECT TOP 1000 * FROM [EAT_Reporting_BSOL].[Reference].[LSOA_2021_WARD_LAD]
```

```{sql}
#| connection: sql_connection
#| code-fold: true
#| code-summary: "Show example"
#| eval: false

UPDATE      T1
SET             T1.[lad_code]   = T2.[LAD22CD]
 
FROM        #BSOL_OF_tbStaging_NumeratorData T1
 
INNER JOIN  [EAT_Reporting_BSOL].[Reference].[LSOA_2021_WARD_LAD] T2
ON          T1.[lsoa_2021] = T2.[LSOA21CD]
```

### 4.9 Locality (resident) {#sec-4.9-locality-resident}

Use the reference table below to map LSOA 21 to Locality (resident), and update the locality column in the numerator dataset (`#BSOL_OF_tbStaging_NumeratorData`) accordingly.

```{sql}
#| connection: sql_connection
#| code-fold: true
#| code-summary: "Show code"
#| eval: false

SELECT TOP 1000 * FROM [EAT_Reporting_BSOL].[Reference].[LSOA_2021_BSOL_to_Constituency_2025_Locality] 
```

```{sql}
#| connection: sql_connection
#| code-fold: true
#| code-summary: "Show example"
#| eval: false

UPDATE      T1
SET         T1.[locality_res]   = T2.[Locality]

FROM        #BSOL_OF_tbStaging_NumeratorData T1

INNER JOIN  [EAT_Reporting_BSOL].[Reference].[LSOA_2021_BSOL_to_Constituency_2025_Locality] T2
ON          T1.[lsoa_2021] = T2.[LSOA21CD] 
```

### 4.10 IMD {#sec-2.4.10-imd}

The IMD is based on the population-weighted average IMD scores across LSOAs within each Ward.

Use the reference table below to map each Ward to its average IMD quintile, and update the IMD column in the numerator dataset (`#BSOL_OF_tbStaging_NumeratorData`) accordingly.

```{sql}
#| connection: sql_connection
#| code-fold: true
#| code-summary: "Show code"
#| eval: false

SELECT TOP 1000 * FROM [EAT_Reporting_BSOL].[OF].[OF2_Reference_Ward_To_IMD] 
```

```{sql}
#| connection: sql_connection
#| code-fold: true
#| code-summary: "Show example"
#| eval: false

UPDATE      T1
SET         T1.[IMD]    = T2.[quintile]

FROM        #BSOL_OF_tbStaging_NumeratorData T1

INNER JOIN  [EAT_Reporting_BSOL].[OF].[OF2_Reference_Ward_To_IMD] T2
ON          T1.[ward_code] = T2.[ward_code] 
```

## 5.0 Update columns to use the correct codes {#sec-2.5-update-columns-to-use-the-correct-codes}

### 5.1 Age {#sec-2.5.1-age}

Check the [metadata](https://birminghamandsolihullccg.sharepoint.com/:f:/r/sites/BirminghamandSolihullIntegratedIntelligenceHub/Shared%20Documents/Outcome%20Framework%20Rebuild/Metadata?csf=1&web=1&e=2HFEtp) file to identify the age group requirements for this indicator.

Also check the value type for the indicator. For example, if the value type is *directly age-standardised rate*, the age should be grouped into 5-year age bands. Otherwise, the age should follow the groupings specified in the [metadata](https://birminghamandsolihullccg.sharepoint.com/:f:/r/sites/BirminghamandSolihullIntegratedIntelligenceHub/Shared%20Documents/Outcome%20Framework%20Rebuild/Metadata?csf=1&web=1&e=2HFEtp) file (e.g., '0-18 yrs', '65+ yrs').

Use the reference table below to map each age to its corresponding 5-year age band.

```{sql}
#| connection: sql_connection
#| code-fold: true
#| code-summary: "Show code"
#| eval: false

SELECT TOP 1000 * FROM [EAT_Reporting_BSOL].[Reference].[tbAge] 
```

```{sql}
#| connection: sql_connection
#| code-fold: true
#| code-summary: "Show example"
#| eval: false

UPDATE      T1
SET         T1.[age] = T2.[AgeBand_5YRS]

FROM        #BSOL_OF_tbStaging_NumeratorData T1

INNER JOIN  [EAT_Reporting_BSOL].[Reference].[tbAge] T2 
ON          T1.[age] = T2.[Age]
```

In this example, each age is mapped to its corresponding 5-year age band, since the indicator's value type is *directly age-standardised rate*. For 5-year age bands, ensure that the maximum band is *85+ years*.

```{sql}
#| connection: sql_connection
#| code-fold: true
#| code-summary: "Show example"
#| eval: false

UPDATE      T1
SET         T1.[age] = '85+'

FROM        #BSOL_OF_tbStaging_NumeratorData T1

WHERE       T1.[age] IN ('85-89', '90-94', '95-99', '100-104', '105-109', '110-114', '115-119', '120-124', '125-129')
```

Replace any unknown or missing ages with the category *Unknown*.

```{sql}
#| connection: sql_connection
#| code-fold: true
#| code-summary: "Show example"
#| eval: false

UPDATE      T1
SET         T1.[age] = 'Unknown'

FROM        #BSOL_OF_tbStaging_NumeratorData T1

WHERE       T1.[age] IS NULL
```

Finally, use the reference table below to map each age group to its code, and update the `age` column in the numerator dataset (`#BSOL_OF_tbStaging_NumeratorData`) accordingly.

```{sql}
#| connection: sql_connection
#| code-fold: true
#| code-summary: "Show code"
#| eval: false

SELECT TOP 1000 * FROM [EAT_Reporting_BSOL].[OF].[OF2_Reference_Age_Group]
```

```{sql}
#| connection: sql_connection
#| code-fold: true
#| code-summary: "Show example"
#| eval: false

UPDATE      T1
SET         T1.[age] = T2.[age_code]

FROM        #BSOL_OF_tbStaging_NumeratorData T1

INNER JOIN  [EAT_Reporting_BSOL].[OF].[OF2_Reference_Age_Group]  T2 
ON          T1.[age] = T2.[age_group]
```

### 5.2 Sex {#sec-5.2-sex}

Apply '999' code to the `sex` column in the numerator dataset (`#BSOL_OF_tbStaging_NumeratorData`), which corresponds to 'All (Persons)'.

```{sql}
#| connection: sql_connection
#| code-fold: true
#| code-summary: "Show example"
#| eval: false

UPDATE      T1
SET         T1.[sex] = '999' -- All (persons)

FROM        #BSOL_OF_tbStaging_NumeratorData T1
```

### 5.3 Ethnicity {#sec-5.3-ethnicity}

Use the reference table below to map each ethnicity to its code, and update the `ethnicity_code` column in the numerator dataset (`#BSOL_OF_tbStaging_NumeratorData`) accordingly.

```{sql}
#| connection: sql_connection
#| code-fold: true
#| code-summary: "Show code"
#| eval: false

SELECT TOP 1000 * FROM [EAT_Reporting_BSOL].[OF].[OF2_Reference_Ethnicity] 
```

```{sql}
#| connection: sql_connection
#| code-fold: true
#| code-summary: "Show example"
#| eval: false

UPDATE      T1
SET         T1.[ethnicity_code] = T2.[ethnicity_code]

FROM        #BSOL_OF_tbStaging_NumeratorData T1

INNER JOIN [EAT_Reporting_BSOL].[OF].[OF2_Reference_Ethnicity] T2
ON          T1.[ethnicity_code] = T2.[nhs_code]
```

### 5.4 IMD {#sec-5.4-imd}

Use the reference table below to map each IMD to its code, and update the IMD column in the numerator dataset (`#BSOL_OF_tbStaging_NumeratorData`) accordingly.

```{sql}
#| connection: sql_connection
#| code-fold: true
#| code-summary: "Show code"
#| eval: false

SELECT TOP 1000 * FROM [EAT_Reporting_BSOL].[OF].[OF2_Reference_IMD] 
```

```{sql}
#| connection: sql_connection
#| code-fold: true
#| code-summary: "Show example"
#| eval: false

UPDATE      T1
SET         T1.[imd] = T2.[imd_code]

FROM        #BSOL_OF_tbStaging_NumeratorData T1

INNER JOIN [EAT_Reporting_BSOL].[OF].[OF2_Reference_IMD] T2
ON          T1.[imd] = T2.[imd_quintile]
```

### 5.5 Ward, LAD, Locality (resident) {#sec-5.5-ward-lad-locality-resident}

Use the reference table below to map each Ward, LAD, and Locality (resident) to its code, and update the respective columns in the numerator dataset (`#BSOL_OF_tbStaging_NumeratorData`) accordingly.

```{sql}
#| connection: sql_connection
#| code-fold: true
#| code-summary: "Show code"
#| eval: false

SELECT TOP 1000 * FROM [EAT_Reporting_BSOL].[OF].[OF2_Reference_Geography] 
```

```{sql}
#| connection: sql_connection
#| code-fold: true
#| code-summary: "Show example"
#| eval: false

--Ward 

UPDATE      T1
SET         T1.[ward_code] = T2.[aggregation_id]

FROM        #BSOL_OF_tbStaging_NumeratorData T1

INNER JOIN  [EAT_Reporting_BSOL].[OF].[OF2_Reference_Geography]  T2 
ON          T1.[ward_code] = T2.[aggregation_code]

--Locality (resident) 

UPDATE      T1
SET         T1.[locality_res] = T2.[aggregation_id]

FROM        #BSOL_OF_tbStaging_NumeratorData T1

INNER JOIN  [EAT_Reporting_BSOL].[OF].[OF2_Reference_Geography]  T2 
ON          T1.[locality_res] = T2.[aggregation_label]

--LAD 

UPDATE      T1
SET         T1.[lad_code] = T2.[aggregation_id]

FROM        #BSOL_OF_tbStaging_NumeratorData T1

INNER JOIN  [EAT_Reporting_BSOL].[OF].[OF2_Reference_Geography]  T2 
ON          T1.[lad_code] = T2.[aggregation_code]
```

## 6.0 Aggregate dataset {#sec-6.0-aggregate-dataset}

The following steps will guide you through aggregating the numerator dataset (`#BSOL_OF_tbStaging_NumeratorData`) to geography levels (Ward, Locality resident, LAD) with demographic splits.

The aggregated dataset should contain the following columns:

-   Indicator ID column: `indicator_id`

-   Start and end dates of the financial year: `start_date`, `end_date`

-   Sum of numerator

-   Demographic columns: `imd_code`, `age_group_code`, `sex_code`, `ethnicity_code`

-   Blank (NULL) columns: `denominator`, `indicator_value`, `lower_ci95`, `upper_ci95`

-   Geography column: `aggregation_id`

-   Creation date column, which is the current date: `creation_date`

-   Value type column, as specified in the [metadata](https://birminghamandsolihullccg.sharepoint.com/:f:/r/sites/BirminghamandSolihullIntegratedIntelligenceHub/Shared%20Documents/Outcome%20Framework%20Rebuild/Metadata?csf=1&web=1&e=2HFEtp) file: `value_type_code`

-   Source column specifying where the indicator is derived from, as specified in the [metadata](https://birminghamandsolihullccg.sharepoint.com/:f:/r/sites/BirminghamandSolihullIntegratedIntelligenceHub/Shared%20Documents/Outcome%20Framework%20Rebuild/Metadata?csf=1&web=1&e=2HFEtp) file: `source_code`

### 6.1 Ward geography {#sec-2.6.1-ward-geography}

```{sql}
#| connection: sql_connection
#| code-fold: true
#| code-summary: "Show example"
#| eval: false

SELECT      DISTINCT 
            T1.[indicator_id]
,           CAST(LEFT(T1.[financial_year], 4) + '-04-01' AS DATE) AS start_date
,           CAST('20' + RIGHT(T1.[financial_year], 2) + '-03-31' AS DATE) AS end_date
,           SUM(T1.[numerator]) AS numerator
,           CAST(NULL AS INT) AS denominator
,           CAST(NULL AS NUMERIC) AS indicator_value
,           CAST(NULL AS NUMERIC) AS lower_ci95
,           CAST(NULL AS NUMERIC) AS upper_ci95
,           T1.[imd] AS imd_code
,           T1.[ward_code] AS aggregation_id
,           T1.[age] AS age_group_code
,           T1.[sex] AS sex_code
,           T1.[ethnicity_code] 
,           CAST(CURRENT_TIMESTAMP AS DATE) AS creation_date
,           '4' AS value_type_code --DASR
,           '1' AS source_code -- SQL

FROM        #BSOL_OF_tbStaging_NumeratorData T1

GROUP BY 
            T1.[indicator_id]
,           CAST(LEFT(T1.[financial_year], 4) + '-04-01' AS DATE)
,           CAST('20' + RIGHT(T1.[financial_year], 2) + '-03-31' AS DATE)
,           T1.[imd]
,           T1.[ward_code] 
,           T1.[sex]
,           T1.[age]
,           T1.[ethnicity_code] 

```

### 6.2 LAD geography {#sec-2.6.2-lad-geography}

```{sql}
#| connection: sql_connection
#| code-fold: true
#| code-summary: "Show example"
#| eval: false

SELECT      DISTINCT
            T1.[indicator_id]
,           CAST(LEFT(T1.financial_year, 4) + '-04-01' AS DATE) AS start_date
,           CAST('20' + RIGHT(T1.financial_year, 2) + '-03-31' AS DATE) AS end_date
,           SUM(T1.numerator) AS numerator
,           CAST(NULL AS INT) AS denominator
,           CAST(NULL AS NUMERIC) AS indicator_value
,           CAST(NULL AS NUMERIC) AS lower_ci95
,           CAST(NULL AS NUMERIC) AS upper_ci95
,           T1.[imd] AS imd_code
,           T1.[lad_code] AS aggregation_id
,           T1.[age] AS gae_group_code
,           t1.[sex] AS sex_code 
,           T1.[ethnicity_code] AS ethnicity_code
,           CAST(CURRENT_TIMESTAMP AS date) AS creation_date
,           '4' AS value_type_code --DASR
,           '1' AS source_code
FROM        #BSOL_OF_tbStaging_NumeratorData T1

GROUP BY 
            T1.[indicator_id]
,           CAST(LEFT(T1.[financial_year], 4) + '-04-01' AS DATE)
,           CAST('20' + RIGHT(T1.[financial_year], 2) + '-03-31' AS DATE)
,           T1.[imd]
,           T1.[lad_code]
,           T1.[age]
,           T1.[sex]
,           T1.[ethnicity_code] 

```

### 6.3 Locality (resident) geography {#sec-6.3-locality-(resident-geography-}

```{sql}
#| connection: sql_connection
#| code-fold: true
#| code-summary: "Show example"
#| eval: false

SELECT      DISTINCT
            T1.[indicator_id]
,           CAST(LEFT(T1.[financial_year], 4) + '-04-01' AS DATE) AS start_date
,           CAST('20' + RIGHT(T1.[financial_year], 2) + '-03-31' AS DATE) AS end_date
,           SUM(T1.[numerator]) AS numerator
,           CAST(NULL AS INT) AS denominator
,           CAST(NULL AS NUMERIC) AS indicator_value
,           CAST(NULL AS NUMERIC) AS lower_ci95
,           CAST(NULL AS NUMERIC) AS upper_ci95
,           T1.[imd] AS imd_code
,           T1.[locality_res] AS aggregation_id
,           T1.[age] AS age_group_code
,           T1.[sex] AS sex_code 
,           T1.[ethnicity_code]
,           CAST(CURRENT_TIMESTAMP AS DATE) AS creation_date
,           '4' AS value_type_code --DASR
,           '1' AS source_code -- SQL
FROM        #BSOL_OF_tbStaging_NumeratorData T1
    
WHERE       [locality_res] <> 'Non-bsol'
    
GROUP BY 
            T1.[indicator_id]
,           CAST(LEFT(T1.[financial_year], 4) + '-04-01' AS DATE)
,           CAST('20' + RIGHT(T1.[financial_year], 2) + '-03-31' AS DATE)
,           T1.[imd]
,           T1.[locality_res]
,           T1.[age]
,           T1.[sex]
,           T1.[ethnicity_code] 

)

```

## 7.0 Insert data into staging table {#sec-2.7-insert-data-into-staging-table}

You can union those three datasets for Ward, Locality (resident), and LAD geographies created in the previous steps, and insert them into the staging table for the processed indicator data created in [Step 1.3](#sec-2.1.3-staging-table-for-processed-indicator-data).

For the Locality geography, ensure that 'Non-BSOL' locality is removed from the dataset.

```{sql}
#| connection: sql_connection
#| code-fold: true
#| code-summary: "Show example"
#| eval: false

INSERT INTO #BSOL_OF_tbStaging_SUS_Data (
            [indicator_id]
,           [start_date]
,           [end_date]
,           [numerator]
,           [denominator]
,           [indicator_value]
,           [lower_ci95]
,           [upper_ci95]
,           [imd_code]
,           [aggregation_id]
,           [age_group_code]
,           [sex_code]
,           [ethnicity_code]
,           [creation_date]
,           [value_type_code]
,           [source_code]
)

-- Ward Geography
(SELECT     DISTINCT 
            T1.[indicator_id]
,           CAST(LEFT(T1.[financial_year], 4) + '-04-01' AS DATE) AS start_date
,           CAST('20' + RIGHT(T1.[financial_year], 2) + '-03-31' AS DATE) AS end_date
,           SUM(T1.[numerator]) AS numerator
,           CAST(NULL AS INT) AS denominator
,           CAST(NULL AS NUMERIC) AS indicator_value
,           CAST(NULL AS NUMERIC) AS lower_ci95
,           CAST(NULL AS NUMERIC) AS upper_ci95
,           T1.[imd] AS imd_code
,           T1.[ward_code] AS aggregation_id
,           T1.[age] AS age_group_code
,           T1.[sex] AS sex_code
,           T1.[ethnicity_code] 
,           CAST(CURRENT_TIMESTAMP AS DATE) AS creation_date
,           '4' AS value_type_code --DASR
,           '1' AS source_code -- SQL

FROM        #BSOL_OF_tbStaging_NumeratorData T1

GROUP BY 
            T1.[indicator_id]
,           CAST(LEFT(T1.[financial_year], 4) + '-04-01' AS DATE)
,           CAST('20' + RIGHT(T1.[financial_year], 2) + '-03-31' AS DATE)
,           T1.[imd]
,           T1.[ward_code] 
,           T1.[sex]
,           T1.[age]
,           T1.[ethnicity_code] 

UNION

-- LAD Geography
SELECT      DISTINCT
            T1.[indicator_id]
,           CAST(LEFT(T1.financial_year, 4) + '-04-01' AS DATE) AS start_date
,           CAST('20' + RIGHT(T1.financial_year, 2) + '-03-31' AS DATE) AS end_date
,           SUM(T1.numerator) AS numerator
,           CAST(NULL AS INT) AS denominator
,           CAST(NULL AS NUMERIC) AS indicator_value
,           CAST(NULL AS NUMERIC) AS lower_ci95
,           CAST(NULL AS NUMERIC) AS upper_ci95
,           T1.[imd] AS imd_code
,           T1.[lad_code] AS aggregation_id
,           T1.[age] AS gae_group_code
,           t1.[sex] AS sex_code 
,           T1.[ethnicity_code] AS ethnicity_code
,           CAST(CURRENT_TIMESTAMP AS date) AS creation_date
,           '4' AS value_type_code --DASR
,           '1' AS source_code
FROM        #BSOL_OF_tbStaging_NumeratorData T1

GROUP BY 
            T1.[indicator_id]
,           CAST(LEFT(T1.[financial_year], 4) + '-04-01' AS DATE)
,           CAST('20' + RIGHT(T1.[financial_year], 2) + '-03-31' AS DATE)
,           T1.[imd]
,           T1.[lad_code]
,           T1.[age]
,           T1.[sex]
,           T1.[ethnicity_code] 

UNION 

--Locality Geography
SELECT      DISTINCT
            T1.[indicator_id]
,           CAST(LEFT(T1.[financial_year], 4) + '-04-01' AS DATE) AS start_date
,           CAST('20' + RIGHT(T1.[financial_year], 2) + '-03-31' AS DATE) AS end_date
,           SUM(T1.[numerator]) AS numerator
,           CAST(NULL AS INT) AS denominator
,           CAST(NULL AS NUMERIC) AS indicator_value
,           CAST(NULL AS NUMERIC) AS lower_ci95
,           CAST(NULL AS NUMERIC) AS upper_ci95
,           T1.[imd] AS imd_code
,           T1.[locality_res] AS aggregation_id
,           T1.[age] AS age_group_code
,           T1.[sex] AS sex_code 
,           T1.[ethnicity_code]
,           CAST(CURRENT_TIMESTAMP AS DATE) AS creation_date
,           '4' AS value_type_code --DASR
,           '1' AS source_code -- SQL
FROM        #BSOL_OF_tbStaging_NumeratorData T1
    
WHERE       [locality_res] <> 'Non-bsol'
    
GROUP BY 
            T1.[indicator_id]
,           CAST(LEFT(T1.[financial_year], 4) + '-04-01' AS DATE)
,           CAST('20' + RIGHT(T1.[financial_year], 2) + '-03-31' AS DATE)
,           T1.[imd]
,           T1.[locality_res]
,           T1.[age]
,           T1.[sex]
,           T1.[ethnicity_code] 


)

```

## 8.0 Create dataset with IMD collapsed to 'All' {#sec-8.0-create-dataset-with-imd-collapsed-to-all}

This step enables calculation of rates or other value types by Ethnicity only.

Get all the columns from the staging processed indicator data and assign '999' code to the `imd_code` column, which corresponds to 'All (Persons)' category.

Save the data in a temporary table so that it can later be joined together with the other processed indicator data before inserting them into the final table.

```{sql}
#| connection: sql_connection
#| code-fold: true
#| code-summary: "Show example"
#| eval: false

DROP TABLE IF EXISTS #temp1

SELECT  
            [indicator_id]
,           [start_date]
,           [end_date]
,           SUM([numerator]) AS numerator
,           NULL AS denominator
,           NULL AS indicator_value     
,           NULL AS lower_ci95
,           NULL AS upper_ci95
,           '999' AS imd_code -- All
,           [aggregation_id]
,           [age_group_code]
,           [sex_code]
,           [ethnicity_code]
,           [creation_date]
,           [value_type_code]
,           [source_code]

INTO        #temp1

FROM        #BSOL_OF_tbStaging_SUS_Data

GROUP BY 
            [indicator_id]
,           [start_date]
,           [end_date]
,           [aggregation_id]
,           [age_group_code]
,           [sex_code]
,           [ethnicity_code]
,           [creation_date]
,           [value_type_code]
,           [source_code]

```

## 9.0 Create dataset with Ethnicity collapsed to 'All' {#sec-2.9-create-dataset-with-ethnicity-collapsed-to-all}

This step enables calculation of rates or other value types by IMD only.

Get all the columns from the staging processed indicator data and assign '999' code to the `ethnicity_code` column, which corresponds to 'All (Persons)' category.

Save the data in a temporary table so that it can later be joined together with the other processed indicator data before inserting them into the final table.

```{sql}
#| connection: sql_connection
#| code-fold: true
#| code-summary: "Show example"
#| eval: false

DROP TABLE IF EXISTS #temp2

SELECT  
            [indicator_id]
,           [start_date]
,           [end_date]
,           SUM([numerator]) AS Numerator
,           NULL AS Denominator
,           NULL AS IndicatorValue     
,           NULL AS LowerCI95
,           NULL AS UpperCI95
,           [imd_code]
,           [aggregation_id]
,           [age_group_code]
,           [sex_code]
,           '999' AS [ethnicity_code] -- All
,           [creation_date]
,           [value_type_code]
,           [source_code]

INTO        #temp2

FROM        #BSOL_OF_tbStaging_SUS_Data

GROUP BY 
            [indicator_id]
,           [start_date]
,           [end_date]
,           [imd_code]
,           [aggregation_id]
,           [age_group_code]
,           [sex_code]
,           [creation_date]
,           [value_type_code]
,           [source_code]

```

## 10.0 Insert data into final table {#sec-10.0-insert-data-into-final-table}

Ensure to delete the old data from the final table before re-inserting new data.

Union all datasets (i.e., from tables created in [Step 7.0](#sec-2.7-insert-data-into-staging-table), [Step 8.0](#sec-8.0-create-dataset-with-imd-collapsed-to-all), and [Step 9.0](#sec-2.9-create-dataset-with-ethnicity-collapsed-to-all)) and insert them into the final table.

```{sql}
#| connection: sql_connection
#| code-fold: true
#| code-summary: "Show example"
#| eval: false

DELETE FROM [EAT_Reporting_BSOL].[OF].[OF2_Indicator_SQL_Data]
WHERE indicator_id = 10

INSERT INTO [EAT_Reporting_BSOL].[OF].[OF2_Indicator_SQL_Data]
SELECT * FROM (
    SELECT * FROM #BSOL_OF_tbStaging_SUS_Data
        UNION
    SELECT * FROM #temp1
        UNION
    SELECT * FROM #temp2) AS final

```

# References {#sec-references}

## Metadata {#sec-metadata}

[Metadata](https://birminghamandsolihullccg.sharepoint.com/:f:/r/sites/BirminghamandSolihullIntegratedIntelligenceHub/Shared%20Documents/Outcome%20Framework%20Rebuild/Metadata?csf=1&web=1&e=2HFEtp)

## Reference tables {#sec-reference-tables}

```{sql}
#| connection: sql_connection
#| code-fold: true
#| code-summary: "Show code"
#| eval: false

-- Ethnicity lookup table
SELECT * FROM [EAT_Reporting_BSOL].[OF].[OF2_Reference_Ethnicity]

-- IMD lookup table
SELECT * FROM [EAT_Reporting_BSOL].[OF].[OF2_Reference_IMD]

-- Age group lookup table
SELECT * FROM [EAT_Reporting_BSOL].[OF].[OF2_Reference_Age_Group]

-- Sex lookup table
SELECT * FROM [EAT_Reporting_BSOL].[OF].[OF2_Reference_Sex]

-- Geography lookup table
SELECT * FROM [EAT_Reporting_BSOL].[OF].[OF2_Reference_Geography]

-- Source lookup table
SELECT * FROM [EAT_Reporting_BSOL].[OF].[OF2_Reference_Source]

-- Value type lookup table
SELECT * FROM [EAT_Reporting_BSOL].[OF].[OF2_Reference_Value_Type]

```

## Final tables {#sec-final-tables}

-   Processed indicator data from warehouse

    ```{sql}
    #| connection: sql_connection
    #| code-fold: true
    #| code-summary: "Show code"
    #| eval: false

    -- Final table for the processed indicator data extracted from warehouse
    SELECT * FROM [EAT_Reporting_BSOL].[OF].[OF2_Indicator_SQL_Data]

    ```

-   Processed indicator data from API

    ```{sql}
    #| connection: sql_connection
    #| code-fold: true
    #| code-summary: "Show code"
    #| eval: false

    -- Final table for the processed indicator data extracted from API
    SELECT * FROM [EAT_Reporting_BSOL].[OF].[OF2_Indicator_API_Data]

    ```

-   Processed indicator data from SharePoint

    ```{sql}
    #| connection: sql_connection
    #| code-fold: true
    #| code-summary: "Show code"
    #| eval: false

    -- Final table for the processed indicator data extracted from Sharepoint
    SELECT * FROM [EAT_Reporting_BSOL].[OF].[OF2_Indicator_Sharepoint_Data]
    ```

-   Processed indicator data from other sources

    ```{sql}
    #| connection: sql_connection
    #| code-fold: true
    #| code-summary: "Show code"
    #| eval: false

    -- Final table for the processed indicator data extracted from other sources
    SELECT * FROM [EAT_Reporting_BSOL].[OF].[OF2_Indicator_Other_Data]
    ```
